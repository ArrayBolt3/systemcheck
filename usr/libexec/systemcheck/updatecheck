#!/bin/bash

## Copyright (C) 2025 - 2025 ENCRYPTED SUPPORT LLC <adrelanos@whonix.org>
## See the file COPYING for copying conditions.

set -x

true "$0: START"

set -o errexit
set -o nounset
set -o errtrace
set -o pipefail

## TODO:
## - what if APT is already running

close_notification() {
  ## notification_id might be unset if signal sigterm is received very quickly.
  [[ -v notification_id ]] || notification_id=""
  if [ "$notification_id" = "" ]; then
    return 0
  fi

  qdbus org.freedesktop.Notifications \
    /org/freedesktop/Notifications \
    org.freedesktop.Notifications.CloseNotification \
    "$notification_id"
}

send_notification_wait_exit() {
  local sleep_milliseconds
  ## 6 hours
  sleep_milliseconds=$(( $sleep_seconds * 1000 ))

  local message
  message="$@ Please run systemcheck."

  printf "%s\n" "$message"
  ## Not using '--wait' otherwise notify-send will wait until notification has been dismissed.
  notification_id="$(notify-send --print-id --expire-time="$sleep_milliseconds" --app-name='updatecheck' -- "$message")" || true

  sleep infinity &
  ## Listen for signals.
  wait "$!"
  true "$0: end of script: END"
  exit 0
}

sigterm_trap() {
  close_notification
  true "$0: sigterm_trap: END"
  exit 0
}

update_output_check() {
  ## Example update_output:
  ## > E: Malformed line 1 in source list /etc/apt/sources.list.d/debian.list (type)
  ## > E: The list of sources could not be read.
  ##
  ## Err:4 http://HTTPS///fasttrack.debian.net/debian bullseye-fasttrack InRelease
  ## 500  SSL error: wrong version number [IP: 127.0.0.1 3142]
  if printf '%s' "$update_output" | grep --quiet --ignore-case -E -- '^Error:|^E:|^Err:'; then
    send_notification_wait_exit "Software updates check failure" "Output of command 'leaprun apt-get-update' contained error messages and has been logged to journal."
    printf "%s\n" "output of 'leaprun apt-get-update':"
    printf "%s\n" "---------------------------------------------"
    printf "%s\n" "$update_output"
    printf "%s\n" "---------------------------------------------"
  fi
}

[[ -v sleep_seconds ]] || sleep_seconds="21600"
[[ -v initial_wait_minutes ]] || initial_wait_minutes="2"

trap "sigterm_trap" SIGTERM SIGINT

who_ami="$(whoami)"

if ! leaprun_check_output="$(leaprun --check -- apt-get-update 2>&1)" ; then
  mkdir --parents ~/.systemcheck/status-files
  msg="\
Account '$who_ami' lacks privleap permission. See:
https://www.kicksecure.com/wiki/Systemcheck#updatecheck_for_accounts_other_than_user"
  printf "%s\n" "$msg"
  /usr/libexec/msgcollector/one-time-popup ~/.systemcheck/status-files/leap-run-missing-permission "Software updates check failure" "$msg"
  exit 0
fi

check_attempts=5
for ((i=1; i<=check_attempts; i++)) ; do
  true "$0: INFO: onion-time-pre-script check loop iteration: $i"
  if onion_time_pre_script_output="$(leaprun onion-time-pre-script)" ; then
    true "$0: INFO: leaprun onion-time-pre-script - success. Proceeding."
    break
  fi
  if [ "$i" -ge "$check_attempts" ]; then
    true "$0: INFO: leaprun onion-time-pre-script - failed. Giving up after $check_attempts attempts."
    printf "%s\n" "$onion_time_pre_script_output"
    send_notification_wait_exit "Software updates check failure" "Command 'leaprun onion-time-pre-script' failed. Command output has been logged to journal."
    ## Avoid indefinite loop. Not really needed. Just in case.
    break
  fi
  true "$0: INFO: leaprun onion-time-pre-script - failed. Sleep and try again."
  sleep -- "${initial_wait_minutes}m" &
  wait -- "$!"
done

check_attempts=3
for ((i=1; i<=check_attempts; i++)) ; do
  true "$0: INFO: sdwdate check loop iteration: $i"
  if [ -e /run/sdwdate/success ]; then
    true "$0: INFO: sdwdate /run/sdwdate/success OK."
    break
  elif [ -e /run/sdwdate/first_success ]; then
    true "$0: INFO: sdwdate /run/sdwdate/first_success OK."
    break
  fi
  if [ "$i" -ge "$check_attempts" ]; then
    true "$0: INFO: sdwdate did not complete yet. Giving up after $check_attempts attempts."
    send_notification_wait_exit "Software updates check failure" "sdwdate did not complete yet."
    ## Avoid indefinite loop. Not really needed. Just in case.
    break
  fi
  true "$0: INFO: sdwdate check failed. Sleep and try again."
  sleep -- "${initial_wait_minutes}m" &
  wait -- "$!"
done

## TODO: /usr/libexec/security-misc/apt-get-update duplicate pidfile write_pid_file
if ! update_output="$(leaprun apt-get-update 2>&1)" ; then
  update_output_check
  ## 'leaprun apt-get-update' might exit non-zero but update_output might not contain errors.
  send_notification_wait_exit "Software updates check failure" "Command 'leaprun apt-get-update' failed (non-zero exit code). Command output has been logged to journal."
  printf "%s\n" "output of 'leaprun apt-get-update':"
  printf "%s\n" "---------------------------------------------"
  printf "%s\n" "$update_output"
  printf "%s\n" "---------------------------------------------"
fi

## 'leaprun apt-get-update' might exit 0 but update_output might still contain errors.
update_output_check

## 'wc' can core dump. Example:
## zsh: illegal hardware instruction (core dumped) wc -l
## https://github.com/rspamd/rspamd/issues/5137
true "$0: INFO: Testing wc command..."
if ! printf "%s" | wc -l ; then
  send_notification_wait_exit "Software updates check failure" "Command 'printf \"%s\" | wc -l' failed."
fi

true "$0: INFO: Count upgrades using wc command..."
## Cannot use 'apt-get list --upgradable' because it leads to error:
## > E: Command line option --upgradable is not understood in combination with the other options
##
## Using 'printf' with '>/dev/null' with xtrace (set -x) output.
printf "%s\n" "$0: INFO: ignore warning 'WARNING: apt does not have a stable CLI interface. Use with caution in scripts.'" >/dev/null
if ! update_package_count="$(LC_ALL=C apt list --upgradable | wc -l)" ; then
  send_notification_wait_exit "Software updates check failure" "Command 'apt list --upgradable' failed."
fi

if [[ "$update_package_count" = *[!0-9]* ]]; then
  send_notification_wait_exit "Software updates check failure" "Variable update_package_count is not strictly numeric."
fi

## Remove first counted line by 'apt list --upgradable':
## > Listing... Done
(( update_package_count-- ))

if [ "$update_package_count" = "0" ]; then
   printf "%s\n" "$0: INFO: No updates available."
   exit 0
fi

update_notify_title='Software updates available'
update_notify_body="${update_package_count}"
if (( update_package_count > 1 )); then
   update_notify_body+=' packages have'
else
   update_notify_body+=' package has'
fi
update_notify_body+=' updates available. You can install them at your convenience using the System Maintenance Panel.'

send_notification_wait_exit "${update_notify_title}" "${update_notify_body}"
